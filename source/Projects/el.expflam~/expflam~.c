#include "MSPd.h"static t_class *expflam_class;#define OBJECT_NAME "expflam~"#define MAXFLAMS (16)#define MAXATTACKS (128)#define STOPGAIN (.001)typedef struct{	int attack_count; // number of triggers per flam event	float *attack_times; // trigger times in seconds	int *attack_points; // trigger times in samples	int fdex; // current flam	float gainatten; // attenuation factor	float amp; // current amp	int atks;// number of attacks per flam	long expflam; // internal clock	short active; // flag that flam is turned on} t_flam;typedef struct _expflam{	t_pxobject x_obj;	t_flam *flams; // contain flams	float start_delay; // initial flam delay	float end_delay;// end delay	float atten; // attenuation factor	float slope;// slope of curve	int atks;// number of attacks per flam	float sr;	float *trigvec; // hold input vector (to protect from memory sharing)	float *bypvec; // ditto for flamgate vector	t_double *trigvec64; // hold input vector (to protect from memory sharing)	t_double *bypvec64; // ditto for flamgate vector	short flamgate; // flag to copy input to output without flam	short flamgate_connected; // flag that a flamgate logical signal is connected to inlet 2} t_expflam;void *expflam_new(void);void expflam_setflam(t_expflam *x, t_symbol *msg, short argc, t_atom *argv);void expflam_free(t_expflam *x);void expflam_assist(t_expflam *x, void *b, long msg, long arg, char *dst);void expflam_flamgate(t_expflam *x, t_floatarg tog);void expflam_dsp64(t_expflam *x, t_object *dsp64, short *count, double samplerate, long n, long flags);void expflam_perform64(t_expflam *x, t_object *dsp64, double **ins,                        long numins, double **outs,long numouts, long n,                       long flags, void *userparam);int C74_EXPORT main(void){	t_class *c;	c = class_new("el.expflam~", (method)expflam_new, (method)dsp_free, sizeof(t_expflam), 0,A_GIMME, 0);    class_addmethod(c, (method)expflam_dsp64, "dsp64", A_CANT, 0);	class_addmethod(c, (method)expflam_assist,"assist",A_CANT,0);    class_addmethod(c,(method)expflam_setflam, "setflam", A_GIMME, 0);    class_addmethod(c,(method)expflam_flamgate, "flamgate", A_FLOAT, 0);    class_dspinit(c);	class_register(CLASS_BOX, c);	expflam_class = c;	potpourri_announce(OBJECT_NAME);	return 0;}void expflam_flamgate(t_expflam *x, t_floatarg tog){	x->flamgate = (short) tog;}void expflam_assist(t_expflam *x, void *b, long msg, long arg, char *dst){  if (msg==1) {    switch (arg) {    	case 0: sprintf(dst,"(signal) Trigger Click"); break;		case 1: sprintf(dst,"(signal) Flam Gate"); break;    }  } else if (msg==2) {    sprintf(dst,"(signal) Flam Clicks");  }}void *expflam_new(void){	int i;	    t_expflam *x = (t_expflam *)object_alloc(expflam_class);	    dsp_setup((t_pxobject *)x,2);	    outlet_new((t_pxobject *)x, "signal");		x->flams = (t_flam *) calloc(MAXFLAMS, sizeof(t_flam));   	for(i = 0; i < MAXFLAMS; i++){	  	x->flams[i].attack_times = (float *) calloc(MAXATTACKS, sizeof(float));	  	x->flams[i].attack_points = (int *) calloc(MAXATTACKS, sizeof(int));	}	   	x->trigvec = malloc(8192 * sizeof(float)); // maximum vector size	x->bypvec = malloc(8192 * sizeof(float)); // maximum vector size	x->trigvec64 = malloc(8192 * sizeof(t_double)); // maximum vector size	x->bypvec64 = malloc(8192 * sizeof(t_double)); // maximum vector size    x->sr = sys_getsr();    x->start_delay = .025;    x->end_delay = 0.1;    x->slope = -3.0;    x->atks = 8;    x->atten = 0.8;	    return x;}void expflam_setflam(t_expflam *x, t_symbol *msg, short argc, t_atom *argv){  if( argc != 5 ){    error("%s: setflam format: startdelay enddelay attacks slope gainatten",OBJECT_NAME);    return;  }  x->start_delay = atom_getfloatarg(0,argc,argv) * 0.001;  x->end_delay = atom_getfloatarg(1,argc,argv) * 0.001;  x->atks = (int) atom_getfloatarg(2,argc,argv);  x->slope = atom_getfloatarg(3,argc,argv);  x->atten = atom_getfloatarg(4,argc,argv);//  x->flamgate = 0;  if(x->slope == 0)  	x->slope = .0001;  if(x->start_delay <= 0)  	x->start_delay = .00001;  if(x->end_delay <= 0)  	x->end_delay = .00001;  if(x->atks < 2)  	x->atks = 2;  if(x->atks > MAXATTACKS){  	post("%s: exceeded maximum of %d attacks",OBJECT_NAME, MAXATTACKS);  	x->atks = MAXATTACKS;  }}void expflam_free(t_expflam *x){int i;  dsp_free((t_pxobject *) x);	free(x->trigvec);	free(x->bypvec);  for(i = 0; i < MAXFLAMS; i++){  	free(x->flams[i].attack_times);  	free(x->flams[i].attack_points);  }  free(x->flams);	}void expflam_perform64(t_expflam *x, t_object *dsp64, double **ins,                     long numins, double **outs,long numouts, long n,                    long flags, void *userparam){    int i,j,k;	t_double *in_vec = ins[0];	t_double *in2_vec = ins[1];	t_double *out_vec = outs[0];		t_double *trigvec = x->trigvec64;	t_double *flamgate_vec = x->bypvec64;	t_flam *flams = x->flams;	int atks = x->atks;	float atten = x->atten;	float slope = x->slope;	float start_delay = x->start_delay;	float end_delay = x->end_delay;	float sr = x->sr;	short flamgate_connected = x->flamgate_connected;		/* in flamgate mode copy input to output and return */	if(x->flamgate){		memcpy( (void *)out_vec, (void *)in_vec, n * sizeof(float) );		return;	}	/* copy input vectors */	memcpy( (void *)flamgate_vec, (void *)in2_vec, n * sizeof(float) );// the order of these mcopies matters	memcpy( (void *)trigvec, (void *)in_vec, n * sizeof(float) );	memcpy( (void *)out_vec, (void *)in_vec, n * sizeof(float) );// copy triggers to output for a start        	/* look for activation triggers */	for(i = 0; i < n; i++){		if(trigvec[i] && (flamgate_vec[i] || ! flamgate_connected) ){				j = 0;  			while(flams[j].active && j < MAXFLAMS){				++j;			}			if(j >= MAXFLAMS){				// post("too many flams");							}			else {				flams[j].active = 1;				flams[j].attack_times[0] = 0.0;				flams[j].attack_points[0] = i;				flams[j].gainatten = atten;				flams[j].amp = trigvec[i];				flams[j].expflam = 0;				flams[j].fdex = 0;				flams[j].atks = atks;								for(k = 1; k < atks; k++){					flams[j].attack_times[k] = start_delay + (end_delay - start_delay) * ((1.0 - exp((float)k * slope/((float)atks-1.0)))/(1.0-exp(slope)));					flams[j].attack_times[k] += flams[j].attack_times[k - 1];					flams[j].attack_points[k] = flams[j].attack_times[k] * sr + i;				}									}		}	}	/* now iterate through active flams */	for( i = 0; i < n; i++){		for(j = 0; j < MAXFLAMS; j++){			if(flams[j].active){				if(flams[j].expflam >= flams[j].attack_points[flams[j].fdex]){					out_vec[i] += flams[j].amp;					flams[j].amp *= flams[j].gainatten;					if( flams[j].amp <= STOPGAIN ){						flams[j].active = 0;					}					flams[j].fdex++;					if(flams[j].fdex >= flams[j].atks){						flams[j].active = 0;					}				}				flams[j].expflam++;			}		}	}}void expflam_dsp64(t_expflam *x, t_object *dsp64, short *count, double samplerate, long n, long flags){    // zero sample rate, go die    if(!samplerate)        return;    x->flamgate_connected = count[1];    object_method(dsp64, gensym("dsp_add64"),x,expflam_perform64,0,NULL);}
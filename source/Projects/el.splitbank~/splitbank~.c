#include "MSPd.h"// #include "fftease.h"#define OSCBANK_TABLE_LENGTH (8192)#define OSCBANK_DEFAULT_TOPFREQ (15000.0)#define MAXSTORE (1024)#define OBJECT_NAME "splitbank~"// from fftease.h#define BIGGER_THAN_MSP_VECTOR 0#define SMALLER_THAN_MSP_VECTOR 1#define EQUAL_TO_MSP_VECTOR 2#define FFTEASE_DEFAULT_FFTSIZE 1024#define FFTEASE_DEFAULT_OVERLAP 8#define FFTEASE_DEFAULT_WINFAC 1#define MAX_FFTSIZE 16384#define MAX_D (MAX_FFTSIZE / FFTEASE_DEFAULT_OVERLAP)// maximum signal vector size#define MAX_VECTOR_SIZE 4096static t_class *splitbank_class;typedef struct{    int R;    int	N;    int	N2;    int	Nw;    int	Nw2;    int	vector_size;    int	i;    int	in_count;    t_double *Wanal;    t_double *Wsyn;    t_double *Hwin;    t_double *complex_spectrum;    t_double *interleaved_spectrum;    t_double *input_buffer;    t_double *output_buffer;    // for convert    t_double *c_lastphase_in;    t_double *c_lastphase_out;    t_double c_fundamental;    t_double c_factor_in;    t_double c_factor_out;    t_double P;    t_double table_length;    t_double table_si;    int first;    t_double i_vector_size;    t_double *lastamp;    t_double *lastfreq;    t_double *index;    t_double *table;    t_double pitch_increment;        int lo_bin;    int hi_bin;    t_double synthesis_threshold;        int overlap;    int winfac;        t_double user_lofreq;    t_double user_hifreq;    t_double curfreq;    t_double mult;    t_double *trigland;    int *bitshuffle;        t_double *internalInputVector; // hold input data from smaller MSP buffers    t_double *internalOutputVector; // hold output data for smaller MSP buffers} t_oscbank;typedef struct _splitbank{    t_pxobject x_obj;    t_oscbank **obanks;    int N;    int Nw;    int N2;    int R;    int D; // new member    int overlap;    void *list_outlet;    t_atom *list_data;    int *bin_tmp;    int ramp_frames;    int frames_left;    t_double frame_duration;    int vector_size;    int table_offset;    int bin_offset;    t_double *last_mag;    t_double *current_mag;    int *last_binsplit;    int *current_binsplit;    int **stored_binsplits;    short *stored_slots;    t_double *in_amps;    short new_distribution;    short interpolation_completed;    short initialize;    short manual_override;    t_double manual_control_value;    short mute;    short powerfade;    int channel_count;    long countdown_samps; // samps for a given fadetime    long counter;    int hopsamps;    t_double frac; // how far along we are in the interpolation    // Internal variables from libfftease    t_double synt;    t_double *internalInputVector; // hold input data from smaller MSP buffers    t_double **internalOutputVectors; // hold output data for smaller MSP buffers [ARRAY]    int operationRepeat; // how many times to do whatever on each perform call    int operationCount; // keep track of where we are in buffer operation    int bufferStatus; // relations between MSP vector size and internal buffer size    int MSPVectorSize; // what it says    short obank_flag; // resynthesis method flag    short init_status; // whether initialization has successfully occurred    short noalias; // inhibit aliasing in oscbank mode    t_double nyquist; // nyquest frequency == R/2    short initialized; // set to 0 for the first time in new(); after that it will be 1    int first_time; // initialization flag} t_splitbank;void *splitbank_new(t_symbol *s, int argc, t_atom *argv);void splitbank_assist (t_splitbank *x, void *b, long msg, long arg, char *dst);void splitbank_showstate( t_splitbank *x );void splitbank_manual_override( t_splitbank *x, t_floatarg toggle );void splitbank_setstate( t_splitbank *x, t_symbol *msg, short argc, t_atom *argv);void splitbank_ramptime( t_splitbank *x, t_symbol *msg, short argc, t_atom *argv);int rand_index( int max);void splitbank_scramble (t_splitbank *x);void splitbank_store( t_splitbank *x, t_floatarg location );void splitbank_recall( t_splitbank *x, t_floatarg location );void splitbank_powerfade( t_splitbank *x, t_floatarg toggle );void splitbank_maxfreq( t_splitbank *x, t_floatarg freq );void splitbank_minfreq( t_splitbank *x, t_floatarg freq );void splitbank_mute( t_splitbank *x, t_floatarg toggle );void splitbank_fftinfo( t_splitbank *x);void splitbank_free( t_splitbank *x );void splitbank_overlap( t_splitbank *x, t_floatarg ofac );void splitbank_spliti( t_splitbank *x,  t_double *dest_mag, int start, int end, t_double oldfrac);void splitbank_split(t_splitbank *x, int *binsplit, t_double *dest_mag, int start, int end );int splitbank_closestPowerOfTwo(int p);void fftease_obank_analyze( t_oscbank *x ) ;void fftease_obank_initialize ( t_oscbank *x, t_double lo_freq, t_double hi_freq, int overlap,                               int R, int vector_size, int N, int first);void fftease_obank_transpose( t_oscbank *x );void fftease_obank_synthesize( t_oscbank *x );void fftease_obank_destroy( t_oscbank *x );void fftease_shiftin( t_oscbank *x, t_double *input );void fftease_shiftout( t_oscbank *x, t_double *output );void fftease_obank_topfreq( t_oscbank *x, t_double topfreq );void fftease_obank_bottomfreq( t_oscbank *x, t_double bottomfreq );void rfft( t_double *x, int N, int forward );void cfft( t_double *x, int NC, int forward );void bitreverse( t_double *x, int N );void fold( t_double *I, t_double *W, int Nw, t_double *O, int N, int n );void init_rdft(int n, int *ip, t_double *w);void rdft(int n, int isgn, t_double *a, int *ip, t_double *w);void bitrv2(int n, int *ip, t_double *a);void cftsub(int n, t_double *a, t_double *w);void rftsub(int n, t_double *a, int nc, t_double *c);void makewt(int nw, int *ip, t_double *w);void makect(int nc, int *ip, t_double *c);void makewindows( t_double *H, t_double *A, t_double *S, int Nw, int N, int I );void makehamming( t_double *H, t_double *A, t_double *S, int Nw, int N, int I,int odd );void makehanning( t_double *H, t_double *A, t_double *S, int Nw, int N, int I,int odd );void convert(t_double *S, t_double *C, int N2, t_double *lastphase, t_double fundamental, t_double factor );void splitbank_assist(t_splitbank *x, void *b, long m, long a, char *s);void splitbank_dsp64(t_splitbank *x, t_object *dsp64, short *count, double samplerate, long maxvectorsize, long flags);void splitbank_perform64(t_splitbank *x, t_object *dsp64, double **ins,                         long numins, double **outs,                         long numouts, long vectorsize,                         long flags, void *userparam);void do_splitbank(t_splitbank *x);//////////int C74_EXPORT main(void){    t_class *c;    c = class_new("el.splitbank~", (method)splitbank_new, (method)splitbank_free, sizeof(t_splitbank), 0, A_GIMME, 0);        class_addmethod(c, (method)splitbank_assist,"assist",A_CANT,0);    class_addmethod(c, (method)splitbank_mute, "mute", A_FLOAT, 0);    class_addmethod(c, (method)splitbank_dsp64, "dsp64", A_CANT,0);    class_addmethod(c, (method)splitbank_showstate, "showstate",0);    class_addmethod(c, (method)splitbank_manual_override, "manual_override",A_FLOAT,0);    class_addmethod(c, (method)splitbank_store, "store",A_FLOAT,0);    class_addmethod(c, (method)splitbank_recall, "recall",A_FLOAT,0);    class_addmethod(c, (method)splitbank_setstate, "setstate",A_GIMME,0);    class_addmethod(c, (method)splitbank_ramptime, "ramptime",A_GIMME,0);    class_addmethod(c, (method)splitbank_powerfade, "powerfade",A_FLOAT,0);    class_addmethod(c, (method)splitbank_minfreq, "minfreq",A_FLOAT,0);    class_addmethod(c, (method)splitbank_maxfreq, "maxfreq",A_FLOAT,0);    class_addmethod(c, (method)splitbank_overlap, "overlap",A_FLOAT,0);    class_addmethod(c, (method)splitbank_scramble, "scramble",0);    class_addmethod(c, (method)splitbank_fftinfo, "fftinfo",0);    class_dspinit(c);    class_register(CLASS_BOX, c);    splitbank_class = c;        potpourri_announce(OBJECT_NAME);    return 0;}void splitbank_overlap( t_splitbank *x, t_floatarg ofac ){    x->overlap = splitbank_closestPowerOfTwo( (int)ofac );}void splitbank_powerfade( t_splitbank *x, t_floatarg toggle ){    x->powerfade = (short)toggle;}void splitbank_mute( t_splitbank *x, t_floatarg toggle ){    x->mute = (short)toggle;}void splitbank_fftinfo( t_splitbank *x){    post("FFT size: %d", x->N);    post("Overlap Factor: %d", x->overlap);    post("Hop size: %d", x->hopsamps);}void splitbank_manual_override( t_splitbank *x, t_floatarg toggle ){    x->manual_override = (short)toggle;}void splitbank_free( t_splitbank *x ){    int i;    if(x->initialize == 0){        sysmem_freeptr(x->list_data) ;        sysmem_freeptr(x->current_binsplit);        sysmem_freeptr(x->last_binsplit);        sysmem_freeptr(x->current_mag);        sysmem_freeptr(x->last_mag);        sysmem_freeptr(x->bin_tmp);        sysmem_freeptr(x->stored_slots);        sysmem_freeptr(x->in_amps);        for( i = 0; i < MAXSTORE; i++ ){            sysmem_freeptr(x->stored_binsplits[i]);        }        sysmem_freeptr(x->stored_binsplits);        for(i = 0; i < x->channel_count; i++){            fftease_obank_destroy(x->obanks[i]);        }        sysmem_freeptr(x->obanks);    }}void splitbank_maxfreq( t_splitbank *x, t_floatarg freq ){    int i;    for(i = 0; i < x->channel_count; i++){        fftease_obank_topfreq( x->obanks[i], freq);    }}void splitbank_minfreq( t_splitbank *x, t_floatarg freq ){    int i;    for(i = 0; i < x->channel_count; i++){        fftease_obank_bottomfreq( x->obanks[i], freq);    }}void splitbank_store( t_splitbank *x, t_floatarg loc ){    int **stored_binsplits = x->stored_binsplits;    int *current_binsplit = x->current_binsplit;    short *stored_slots = x->stored_slots;    int location = (int) loc;    int i;        if( location < 0 || location > MAXSTORE - 1 ){        error("location must be between 0 and %d, but was %d", MAXSTORE, location);        return;    }    for(i = 0; i < x->N2; i++ ){        stored_binsplits[location][i] = current_binsplit[i];    }    stored_slots[location] = 1;        // post("stored bin split at location %d", location);}void splitbank_recall( t_splitbank *x, t_floatarg loc ){    int **stored_binsplits = x->stored_binsplits;    int *current_binsplit = x->current_binsplit;    int *last_binsplit = x->last_binsplit;    short *stored_slots = x->stored_slots;    int i;    int location = (int) loc;    if( location < 0 || location > MAXSTORE - 1 ){        error("location must be between 0 and %d, but was %d", MAXSTORE, location);        return;    }    if( ! stored_slots[location] ){        error("nothing stored at location %d", location);        return;    }        for(i = 0; i < x->N2; i++ ){        last_binsplit[i] = current_binsplit[i];        current_binsplit[i] = stored_binsplits[location][i];    }        x->new_distribution = 1;    x->interpolation_completed = 0;    x->frames_left = x->ramp_frames;    if(! x->ramp_frames) { // Ramp Off - Immediately set last to current        for( i = 0; i < x->N2; i++ ){            x->last_binsplit[ i ] = x->current_binsplit[ i ];        }    }}int splitbank_closestPowerOfTwo(int p){    int base = 2;    if(p > 2){        while(base < p){            base *= 2;        }    }    return base;}void *splitbank_new(t_symbol *s, int argc, t_atom *argv){    t_splitbank *x = (t_splitbank *)object_alloc(splitbank_class);    int i;    int max_N2 = MAX_FFTSIZE / 2;        x->channel_count = (int) atom_getfloatarg(0, argc, argv);    x->channel_count = splitbank_closestPowerOfTwo( x->channel_count );    // READ FFT size here        // the second parameter will be FFT size. For now, it's hard coded    x->R = 48000; // temporary to avoid divide by zero in initialization routines    x->N = 1024;    x->Nw = x->N;    x->overlap = 8;    x->D = x->N / x->overlap;    // post("FFT size set to %d\n", x->N);    srand(time(0));    dsp_setup((t_pxobject *)x,x->channel_count + 5);    x->list_outlet = (void *) listout((void *)x);    for(i = 0; i < x->channel_count + 1; i++){        outlet_new((t_object *)x, "signal");    }    x->x_obj.z_misc |= Z_NO_INPLACE;    x->obanks = (t_oscbank **) sysmem_newptrclear(x->channel_count * sizeof(t_oscbank *));    for(i = 0; i < x->channel_count; i++){        x->obanks[i] = (t_oscbank *) sysmem_newptrclear(sizeof(t_oscbank));        fftease_obank_initialize(x->obanks[i], 0.0, 18000.0, x->overlap, x->R, x->D,x->N, 1);    }                x->list_data = (t_atom *) sysmem_newptrclear((MAX_FFTSIZE + 2) * sizeof(t_atom));    x->last_binsplit = (int *) sysmem_newptrclear(max_N2 * sizeof(int));    x->current_binsplit = (int *)sysmem_newptrclear(max_N2 * sizeof(int));    x->bin_tmp = (int *)sysmem_newptrclear(max_N2 * sizeof(int));    x->last_mag = (t_double *)sysmem_newptrclear(max_N2 * sizeof(t_double));    x->current_mag = (t_double *)sysmem_newptrclear(max_N2 * sizeof(t_double));    x->stored_slots = (short *)sysmem_newptrclear(max_N2 * sizeof(short));    x->stored_binsplits = (int **)sysmem_newptrclear(MAXSTORE * sizeof(int *));    for( i = 0; i < MAXSTORE; i++ ){        x->stored_binsplits[i] = (int *)sysmem_newptrclear(max_N2 * sizeof(int));    }    x->in_amps = (t_double *)sysmem_newptrclear((MAX_FFTSIZE + 2) * sizeof(t_double));        x->first_time = 1;        splitbank_scramble(x);        x->mute = 0;    x->table_offset = 0;    x->bin_offset = 0;    x->powerfade = 0;    x->manual_override = 0;    x->countdown_samps = 0;    x->initialize = 1;    return x;}void splitbank_assist (t_splitbank *x, void *b, long msg, long arg, char *dst){    if (msg==1) {        if( arg == 0){            sprintf(dst,"(signal) Sound Input");        } else if( arg > 0 && arg <= x->channel_count ){            sprintf(dst,"(signal) Transposition %ld", arg);        } else if( arg == x->channel_count + 1) {            sprintf(dst,"(signal) Synthesis Threshold");        }        else if( arg == x->channel_count + 2) {            sprintf(dst,"(signal) Table Offset");        }        else if( arg == x->channel_count + 3) {            sprintf(dst,"(signal) Bin Offset");        }        else if( arg == x->channel_count + 4) {            sprintf(dst,"(signal) Manual Control");        }    } else if (msg==2) {        if( arg < x->channel_count){            sprintf(dst,"(signal) Spectrum Segment %ld",arg + 1);        } else if( arg == x->channel_count) {            sprintf(dst,"(signal) Ramp Sync");        } else {            sprintf(dst,"(list) Current Bin State");        }    }}void do_splitbank(t_splitbank *x){            // source for samples? How much to shift in?    // fftease_shiftin( obanks[0], input ); // maybe this gets done in the Perform routine?    int i,j;    int N2 = x->N / 2;    int N = x->N;    int Nw = x->Nw;    int D = x->D;    int channel_count = x->channel_count;    t_double manual_control_value = x->manual_control_value;    t_double frac = x->frac;    int hopsamps = x->hopsamps;    long counter = x->counter;    long countdown_samps = x->countdown_samps;    int *current_binsplit = x->current_binsplit;    int *last_binsplit = x->last_binsplit;    t_oscbank **obanks = x->obanks;    t_double *input = obanks[0]->input_buffer;    t_double *internalInputVector = obanks[0]->internalInputVector;    t_double *in_amps = x->in_amps;        /** END OF DECLARATIONS **/        fftease_obank_analyze(obanks[0]);        //    post("channel count %d\n", channel_count);    // copy input amplitudes from analyzed frame    for( i = 0, j = 0; i < N; i += 2 , j++){        in_amps[j] = obanks[0]->interleaved_spectrum[i];            }        // zero the amps next        for(i = 0; i < channel_count; i++){        for(j = 0; j < N; j += 2){            obanks[i]->interleaved_spectrum[j] = 0.0;        }    }        if( x->manual_override ){        for(i = 0; i < channel_count; i++){            splitbank_spliti(x, obanks[i]->interleaved_spectrum,                             N2*i/channel_count, N2*(i+1)/channel_count, manual_control_value);        }        frac = manual_control_value;    }    else if( x->new_distribution ) {                x->new_distribution = 0;                for(i = 0; i < channel_count; i++){            splitbank_split( x, last_binsplit, obanks[i]->interleaved_spectrum,                            N2*i/channel_count, N2*(i+1)/channel_count);        }        frac = 0.0;    }    else if ( x->interpolation_completed ) {        for(i = 0; i < channel_count; i++){            splitbank_split( x, current_binsplit, obanks[i]->interleaved_spectrum,                            N2*i/channel_count, N2*(i+1)/channel_count);        }        frac = 1.0;    } else {        frac = (float) counter / (float) countdown_samps;        //      post("N2*i/chan count %d, N2*(i+1)/chan count %d N2 %d i %d\n",N2*i/channel_count, N2*(i+1)/channel_count, N2, i);        for(i = 0; i < channel_count; i++){            splitbank_spliti( x, obanks[i]->interleaved_spectrum,                             N2*i/channel_count, N2*(i+1)/channel_count, 1.0 - frac);        }        counter += hopsamps;        if( counter >= countdown_samps )        {            counter = countdown_samps;            x->interpolation_completed = 1;        }    }    // copy frequency information to other banks        for(i = 1; i < channel_count; i++){        for( j = 1; j < N; j += 2){            obanks[i]->interleaved_spectrum[j] = obanks[0]->interleaved_spectrum[j];        }    }        // SYNTHESIS        for(i = 0; i < channel_count; i++){        fftease_obank_synthesize( obanks[i] );    }    x->frac = frac;    x->counter = counter;}void splitbank_perform64(t_splitbank *x, t_object *dsp64, double **ins,                         long numins, double **outs,                         long numouts, long n,                         long flags, void *userparam){    int i,j,k;    t_double frac = x->frac;    int channel_count = x->channel_count;    t_double *synthesis_threshold;    t_double *t_offset;    t_double *b_offset;    t_double *manual_control;    t_double *sync;    int N2 = x->N2;    int N = x->N;    int Nw = x->Nw;    int D = x->D;    int hopsamps = x->hopsamps;    int *current_binsplit = x->current_binsplit;    int *last_binsplit = x->last_binsplit;    long vector_size = n;    t_double *in_amps = x->in_amps;    t_double manual_control_value = x->manual_control_value;    long counter = x->counter;    long countdown_samps = x->countdown_samps;    t_oscbank **obanks = x->obanks;    t_double *outlet;    t_double *input_buffer;    t_double *output_buffer;    t_double mult = obanks[0]->mult;    t_double *MSPInputVector; // point to the MaxMSP input vector    t_double *MSPOutputVector; // point to the current MaxMSP output vector    t_double *internalInputVector;    t_double *internalOutputVector;    int operationRepeat = x->operationRepeat;    int operationCount = x->operationCount;        /** END OF DECLARATIONS **/            if(x->mute){        for(i = 0; i < (channel_count + 1); i++){            outlet = (t_double *) outs[i];            for(j = 0; j < n; j++){                outlet[j] = 0.0;            }        }        // post("muted");        return;    }    /** ASSIGN INLETS AND OUTLETS **/        MSPInputVector = ins[0]; // assign first inlet to MSPInputVector    synthesis_threshold = ins[channel_count + 1]; // these come after channel_count transposition inlets    t_offset = ins[channel_count + 2];    b_offset = ins[channel_count + 3];    manual_control = ins[channel_count + 4];    sync = outs[channel_count]; // sync will be the last outlet on the object        /* ACQUIRE PARAMETERS */        // set pitch factors for each channel. All use the first synthesis threshold (should be zero by default)    for(i = 0; i < channel_count; i++){        obanks[i]->pitch_increment = ins[i+1][0] * obanks[i]->table_si;        obanks[i]->synthesis_threshold = synthesis_threshold[0];    }        x->table_offset = t_offset[0] * N2;    x->bin_offset = b_offset[0] * N2;        x->manual_control_value = manual_control[0];        /* BEGIN DSP LOOP */        // DOUBLE BUFFERED VERSION        input_buffer = obanks[0]->input_buffer;        if( x->bufferStatus == EQUAL_TO_MSP_VECTOR ){        for ( i = 0 ; i < (Nw - vector_size) ; i++ ){            input_buffer[i] = input_buffer[i + vector_size];        }        for ( i = (Nw - vector_size) ; i < Nw; i++ ) {            input_buffer[i] = *MSPInputVector++;        }                do_splitbank(x);                // deal with multichannel outputs here                for(i = 0; i < channel_count; i++){            MSPOutputVector = outs[i];            output_buffer = obanks[i]->output_buffer;            for ( j = 0; j < vector_size; j++ ){                *MSPOutputVector++ = output_buffer[j] * mult;            }            for ( j = 0; j < Nw - vector_size; j++ ){                output_buffer[j] = output_buffer[j + vector_size];            }            for ( j = Nw - vector_size; j < Nw; j++ ){                output_buffer[i] = 0.0;            }            obanks[i]->in_count += vector_size; // THIS SEEMS KEY TO SUCCESS ...        }            }    else if( x->bufferStatus == SMALLER_THAN_MSP_VECTOR ) {        for(k = 0; k < operationRepeat; k++ ){                        //  sysmem_copyptr(input_buffer + D, input_buffer, (Nw - D) * sizeof(t_double));            for ( i = 0 ; i < (Nw - D) ; i++ ){                input_buffer[i] = input_buffer[i + D];            }                        //  sysmem_copyptr(MSPInputVector + (D * k), input_buffer + (Nw-D), D * sizeof(t_double));                        for ( i = 0 ; i < (Nw - D) ; i++ ){                input_buffer[i + (Nw - D)] = MSPInputVector[i + (D * k)];            }                        do_splitbank(x);                        for(i = 0; i < channel_count; i++){                MSPOutputVector = outs[i];                output_buffer = obanks[i]->output_buffer;                                for ( j = 0; j < D; j++ ){                    MSPOutputVector[j + (D * k)] = output_buffer[j] * mult;                }                for ( j = 0; j < Nw - D; j++ ){                    output_buffer[j] = output_buffer[j + D];                }                                //  sysmem_copyptr(output_buffer + D, output_buffer, (Nw-D) * sizeof(t_double));                                for ( j = Nw - D; j < Nw; j++ ){                    output_buffer[i] = 0.0;                }                obanks[i]->in_count += D;            }                    }    }    else if( x->bufferStatus == BIGGER_THAN_MSP_VECTOR ) {                internalInputVector = obanks[0]->internalInputVector;        sysmem_copyptr(MSPInputVector,internalInputVector + (operationCount * vector_size),vector_size * sizeof(t_double));                for(i = 0; i < channel_count; i++){            internalOutputVector = obanks[i]->internalOutputVector;            MSPOutputVector = outs[i];            sysmem_copyptr(internalOutputVector + (operationCount * vector_size),MSPOutputVector,vector_size * sizeof(t_double));        }        operationCount = (operationCount + 1) % operationRepeat;                if( operationCount == 0 ) {                        sysmem_copyptr(input_buffer + D, input_buffer, (Nw - D) * sizeof(t_double));            sysmem_copyptr(internalInputVector, input_buffer + (Nw - D), D * sizeof(t_double));                        do_splitbank(x);                        for(i = 0; i < channel_count; i++){                internalOutputVector = obanks[i]->internalOutputVector;                output_buffer = obanks[i]->output_buffer;                for ( j = 0; j < D; j++ ){                    internalOutputVector[j] = output_buffer[j] * mult;                }                sysmem_copyptr(output_buffer + D, output_buffer, (Nw - D) * sizeof(t_double));                for(j = (Nw-D); j < Nw; j++){                    output_buffer[j] = 0.0;                }                obanks[i]->in_count = (obanks[i]->in_count + x->D) % x->Nw;            }        }    }    for( i = 0; i < n; i++ ){        sync[i] = frac;    }    x->operationCount = operationCount;}void splitbank_scramble (t_splitbank *x){    int i, j;    int used;        int max = x->N2;    int bindex;        int *current_binsplit = x->current_binsplit;    int *last_binsplit = x->last_binsplit;    int *bin_tmp = x->bin_tmp;        x->new_distribution = 1;    x->interpolation_completed = 0;        //  post("scrambling");        // Copy current mapping to last mapping (first time this will be all zeros)        for( i = 0; i < x->N2; i++ ){        last_binsplit[i] = current_binsplit[i];    }            for( i = 0; i < max; i++ ){        bin_tmp[i] = i;    }        used = max;        // This randomly distributes each bin number (to occur once each in a random location)        for( i = 0; i < max; i++ ){        bindex = rand_index( used );        current_binsplit[i] = bin_tmp[bindex];        for(j = bindex; j < used - 1; j++) {            bin_tmp[j] = bin_tmp[j+1];        }        --used;    }    x->counter = 0;    if(! x->countdown_samps ) { // Ramp Off - Immediately set last to current        for( i = 0; i < x->N2; i++ ){            last_binsplit[ i ] = current_binsplit[ i ];        }    }}int rand_index(int max) {    int rand();    return ( rand() % max );}void splitbank_setstate (t_splitbank *x, t_symbol *msg, short argc, t_atom *argv) {    short i;        if( argc != x->N2 ){        error("list must be of length %d, but actually was %d", x->N2, argc);        return;    }    for( i = 0; i < x->N2; i++ ){        x->last_binsplit[ i ] = x->current_binsplit[ i ];        x->current_binsplit[ i ] = 0;    }    for (i=0; i < argc; i++) {        x->current_binsplit[i] = atom_getintarg(i, argc, argv );    }    x->frames_left = x->ramp_frames;    if(! x->ramp_frames) { // Ramp Off - Immediately set last to current        for( i = 0; i < x->N2; i++ ){            x->last_binsplit[ i ] = x->current_binsplit[ i ];        }    }    return;}void splitbank_ramptime (t_splitbank *x, t_symbol *msg, short argc, t_atom *argv) {    float rampdur;    rampdur = atom_getfloatarg(0,argc,argv) * 0.001;    x->countdown_samps = rampdur * x->R;    x->counter = 0;}// REPORT CURRENT SHUFFLE STATUSvoid splitbank_showstate (t_splitbank *x ) {        t_atom *list_data = x->list_data;    short i, count;    count = 0;    for( i = 0; i < x->N2; i++ ) {        atom_setlong(list_data+count,x->current_binsplit[i]);        ++count;    }    outlet_list(x->list_outlet,0L,x->N2,list_data);    return;}void splitbank_split(t_splitbank *x, int *binsplit, t_double *dest_mag, int start, int end ){    int i;    int bindex;    int n = x->N2;    t_double *in_amps = x->in_amps;    int table_offset = x->table_offset;    int bin_offset = x->bin_offset;        if( table_offset  < 0 )        table_offset *= -1;    if( bin_offset  < 0 )        bin_offset *= -1;        for( i = start; i < end; i++){        bindex = binsplit[ (i + table_offset) % n ];        bindex = ( bindex + bin_offset ) % n;        dest_mag[ bindex * 2 ] = in_amps[ bindex ]; // putting amps into interleaved spectrum    }}void splitbank_spliti( t_splitbank *x, t_double *dest_mag, int start, int end, t_double oldfrac){    int i;    int bindex;    int *current_binsplit = x->current_binsplit;    int *last_binsplit = x->last_binsplit;    t_double *current_mag = x->current_mag;    t_double *last_mag = x->last_mag;    t_double *in_amps = x->in_amps;    int bin_offset = x->bin_offset;    int table_offset = x->table_offset;    int n = x->N2;    t_double newfrac;    t_double phase;        //    post("start %d end %d\n", start,end); // These are both zero !!!        if( oldfrac < 0 )        oldfrac = 0;    if( oldfrac > 1.0 )        oldfrac = 1.0;        if( x->powerfade ){        phase = oldfrac * PIOVERTWO;        oldfrac = sin( phase );        newfrac = cos( phase );    } else {        newfrac = 1.0 - oldfrac;    }        if( table_offset  < 0 )        table_offset *= -1;    if( bin_offset  < 0 )        bin_offset *= -1;        for( i = 0; i < n; i++ ){        last_mag[i] = current_mag[i] = 0.0;    }        for( i = start; i < end; i++ ){        bindex = current_binsplit[ (i + table_offset) % n ];        bindex = ( bindex + bin_offset ) % n;        current_mag[ bindex ] = in_amps[ bindex ];                bindex = last_binsplit[ (i + table_offset) % n ];        bindex = ( bindex + bin_offset ) % n;        last_mag[ bindex ] = in_amps[ bindex ];        // post("bindex %d lastmag %f\n", bindex, last_mag[bindex]);    }    for( i = 0; i < n; i++){        if(! current_mag[i] && ! last_mag[i]){            dest_mag[i * 2] = 0.0;        }        else if( current_mag[i] && last_mag[i]) {            dest_mag[i * 2] = current_mag[i];        } else if (  current_mag[i] && ! last_mag[i] ) {            dest_mag[i * 2] = newfrac * current_mag[i];        }        else {            dest_mag[i * 2] = oldfrac * last_mag[i];        }    }    //    post("****\n");}void splitbank_dsp64(t_splitbank *x, t_object *dsp64, short *count, double sr, long maxvectorsize, long flags){    int i;    int R;    int lo_freq = 0;    int hi_freq = 15000;    // int fftsize;    int overlap = x->overlap;    int reset_required = 0;    int D = x->D;    if(x->R != sr || x->vector_size != maxvectorsize || x->initialized == 0){        reset_required = 1;    }    int channel_count = x->channel_count;    // int vector_size;    t_oscbank **obanks = x->obanks;    if( ! sr ){        return;    }   // x->MSPVectorSize = maxvectorsize;    x->vector_size = maxvectorsize;    x->initialize = 1;    x->operationCount = 0;    if( x->D > x->vector_size ){        x->operationRepeat = x->D / x->vector_size;        x->bufferStatus = BIGGER_THAN_MSP_VECTOR;        // post("fftease_set_fft_buffers: bigger than MSP vector");    } else if( x->D < x->vector_size ){        x->operationRepeat = x->vector_size / x->D;        x->bufferStatus = SMALLER_THAN_MSP_VECTOR;        // post("fftease_set_fft_buffers: smaller than MSP buffer");    } else {        x->operationRepeat = 1;        x->bufferStatus = EQUAL_TO_MSP_VECTOR;        // post("fftease_set_fft_buffers: equal to MSP buffer");    }    if(x->initialize || x->R != sr){        x->R = sr;        if( (x->initialize || x->R != sr) && (! x->countdown_samps) ){            x->counter = 0;            x->countdown_samps = 1.0 * x->R; // 1 second fade time by default        }        // x->vector_size = vector_size;        R = (int) x->R;        x->N2 = x->N / 2;        if(x->first_time){            splitbank_scramble( x );            x->first_time = 0;        }        for( i = 0; i < x->N2; i++ ){            x->last_binsplit[i] = x->current_binsplit[i];        }        // INITIALIZE INTERNAL INPUT BUFFERS (MUST DO THIS EARLIER IN THE new FUNCTION)                for(i = 0; i < channel_count; i++){            fftease_obank_initialize(obanks[i], lo_freq, hi_freq, overlap, R, x->D,x->N, 0);        }        x->initialize = 0;    }    x->hopsamps = x->N / x->overlap;    object_method(dsp64, gensym("dsp_add64"),x,splitbank_perform64,0,NULL);}/////////////////////////////////////////**************************************************/void fftease_obank_destroy( t_oscbank *x ){    sysmem_freeptr(x->Wanal);    sysmem_freeptr(x->Wsyn);    sysmem_freeptr(x->Hwin);    sysmem_freeptr(x->complex_spectrum);    sysmem_freeptr(x->interleaved_spectrum);    sysmem_freeptr(x->input_buffer);    sysmem_freeptr(x->output_buffer);    sysmem_freeptr(x->c_lastphase_in);    sysmem_freeptr(x->lastamp);    sysmem_freeptr(x->lastfreq);    sysmem_freeptr(x->index);    sysmem_freeptr(x->table);    sysmem_freeptr(x->bitshuffle);    sysmem_freeptr(x->trigland);}/**************************************************/void fftease_obank_initialize ( t_oscbank *x, t_double lo_freq, t_double hi_freq, int overlap,                               int R, int vector_size, int N, int first){    int i;    int max_N2;    x->overlap = overlap;    x->R = R;    x->vector_size = vector_size;    x->N = N;    x->Nw = x->N;    x->N2 = (x->N)>>1;    x->Nw2 = (x->Nw)>>1;    x->in_count = -(x->Nw);    x->table_length = OSCBANK_TABLE_LENGTH ;    x->user_lofreq = lo_freq;    x->user_hifreq = hi_freq;    x->synthesis_threshold = .001;    x->table_si = (t_double) x->table_length/ (t_double) x->R;    if(first){        max_N2 = MAX_FFTSIZE / 2;        x->Wanal = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->Wsyn = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->Hwin = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->complex_spectrum = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->interleaved_spectrum = (t_double *) sysmem_newptrclear((MAX_FFTSIZE + 2) * sizeof(t_double) );        x->input_buffer = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->output_buffer = (t_double *) sysmem_newptrclear(MAX_FFTSIZE * sizeof(t_double) );        x->c_lastphase_in = (t_double *) sysmem_newptrclear((max_N2 + 1) * sizeof(t_double) );        x->c_lastphase_out = (t_double *) sysmem_newptrclear((max_N2 + 1) * sizeof(t_double) );        x->lastamp = (t_double *) sysmem_newptrclear((MAX_FFTSIZE + 1) * sizeof(t_double) );        x->lastfreq = (t_double *) sysmem_newptrclear((MAX_FFTSIZE + 1) * sizeof(t_double) );        x->index = (t_double *) sysmem_newptrclear((MAX_FFTSIZE + 1) * sizeof(t_double) );        x->table = (t_double *) sysmem_newptrclear(OSCBANK_TABLE_LENGTH * sizeof(t_double) );        x->bitshuffle = (int *) sysmem_newptrclear((MAX_FFTSIZE * 2) * sizeof( int ) );        x->trigland = (t_double *) sysmem_newptrclear((MAX_FFTSIZE * 2) * sizeof( t_double ) );        x->internalInputVector = (t_double *)sysmem_newptrclear(MAX_D * sizeof(t_double)); // move these inside function        x->internalOutputVector = (t_double *) sysmem_newptrclear(MAX_D * sizeof(t_double)); // move these inside function    }    x->mult = 1. / (t_double) x->N;    for( i = 0; i < x->N2 + 1; i++) {        x->c_lastphase_in[i] = x->c_lastphase_out[i] = 0.0;    }    for( i = 0; i < x->N + 1; i++) {        x->lastamp[i] = x->lastfreq[i] = x->index[i] = 0.0;    }    for( i = 0; i < x->Nw; i++ ){        x->input_buffer[i] = x->output_buffer[i] = 0.0;    }    init_rdft( x->N, x->bitshuffle, x->trigland);    makehanning( x->Hwin, x->Wanal, x->Wsyn, x->Nw, x->N, x->vector_size, 0);    x->c_fundamental =  (t_double) x->R/(t_double)x->N ;    x->c_factor_in =  (t_double) x->R/((t_double)x->vector_size * TWOPI);    x->c_factor_out = 1.0 / x->c_factor_in;        if( x->user_hifreq < x->c_fundamental ) {        x->user_hifreq = OSCBANK_DEFAULT_TOPFREQ ;    }    x->hi_bin = 1;    x->curfreq = 0;    while( x->curfreq < x->user_hifreq ) {        ++(x->hi_bin);        x->curfreq += x->c_fundamental ;    }    x->lo_bin = 0;    x->curfreq = 0;    while( x->curfreq < x->user_lofreq ) {        ++(x->lo_bin);        x->curfreq += x->c_fundamental ;    }    if( x->hi_bin > x->N2){        x->hi_bin = x->N2;    }    for ( i = 0; i < x->table_length; i++ ) {        x->table[i] = (t_double) x->N * cos((t_double)i * TWOPI / (t_double)x->table_length);    }    x->P = 1.0 ;    x->i_vector_size = 1. / x->vector_size;    x->pitch_increment = x->P * x->table_length/x->R;}/**************************************************/void  fftease_obank_topfreq( t_oscbank *x, t_double topfreq ){    if( topfreq < x->c_fundamental ) {        topfreq = OSCBANK_DEFAULT_TOPFREQ ;    }        x->hi_bin = 1;    x->curfreq = 0;    while( x->curfreq < topfreq ) {        ++(x->hi_bin);        x->curfreq += x->c_fundamental ;    }    if( x->hi_bin > x->N2)        x->hi_bin = x->N2 ;}/**************************************************/void  fftease_obank_bottomfreq( t_oscbank *x, t_double bottomfreq ){            x->lo_bin = 0;    x->curfreq = 0;    while( x->curfreq < bottomfreq ) {        ++(x->lo_bin);        x->curfreq += x->c_fundamental ;    }    }/**************************************************/void  fftease_obank_analyze( t_oscbank *x ){    fold( x->input_buffer, x->Wanal, x->Nw, x->complex_spectrum, x->N, x->in_count );        rdft( x->N, 1, x->complex_spectrum, x->bitshuffle, x->trigland );        convert( x->complex_spectrum, x->interleaved_spectrum, x->N2, x->c_lastphase_in,            x->c_fundamental, x->c_factor_in );    }/**************************************************/void fftease_shiftin( t_oscbank *x, t_double *input ){    int i;    int vector_size = x->vector_size;    int Nw = x->Nw;    t_double *input_buffer = x->input_buffer;        for ( i = 0 ; i < (Nw - vector_size) ; i++ ){        input_buffer[i] = input_buffer[i + vector_size];    }    for ( i = (Nw - vector_size) ; i < Nw; i++ ) {        input_buffer[i] = *input++;    }    }/**************************************************/void fftease_shiftout( t_oscbank *x, t_double *output ){    int i;    int vector_size = x->vector_size;    int Nw = x->Nw;    t_double *output_buffer = x->output_buffer;    t_double mult = x->mult;        for ( i = 0; i < vector_size; i++ ){        *output++ = output_buffer[i] * mult;    }    for ( i = 0; i < Nw - vector_size; i++ ){        output_buffer[i] = output_buffer[i + vector_size];    }    for ( i = Nw - vector_size; i < Nw; i++ ){        output_buffer[i] = 0.;    }        x->in_count += vector_size;}/**************************************************/void fftease_obank_synthesize( t_oscbank *x ){    int amp, chan, freq;    t_double    a,ainc,f,finc,address;    int n;        t_double synthesis_threshold = x->synthesis_threshold;    t_double *lastfreq = x->lastfreq;    t_double *lastamp = x->lastamp;    int table_length = x->table_length;    t_double *output_buffer = x->output_buffer;    int vector_size = x->vector_size;    t_double i_vector_size = x->i_vector_size;    int lo_bin = x->lo_bin;    int hi_bin = x->hi_bin;    t_double *interleaved_spectrum = x->interleaved_spectrum;    t_double pitch_increment = x->pitch_increment;    t_double *index = x->index;    t_double *table = x->table;        for ( chan = lo_bin; chan < hi_bin; chan++ ) {        freq = ( amp = ( chan << 1 ) ) + 1;        if ( interleaved_spectrum[amp] > synthesis_threshold ){            interleaved_spectrum[freq] *= pitch_increment;            finc = ( interleaved_spectrum[freq] - ( f = lastfreq[chan] ) ) * i_vector_size;            ainc = ( interleaved_spectrum[amp] - ( a = lastamp[chan] ) ) * i_vector_size;            address = index[chan];            for ( n = 0; n < vector_size; n++ ) {                output_buffer[n] += a*table[ (int) address ];                address += f;                while ( address >= table_length )                    address -= table_length;                while ( address < 0 )                    address += table_length;                a += ainc;                f += finc;            }            lastfreq[chan] = interleaved_spectrum[freq];            lastamp[chan] = interleaved_spectrum[amp];            index[chan] = address;        }    }}////////////////////////void init_rdft(int n, int *ip, t_double *w){        int	nw,    nc;        void	makewt(int nw, int *ip, t_double *w);    void	makect(int nc, int *ip, t_double *c);        nw = n >> 2;    makewt(nw, ip, w);        nc = n >> 2;    makect(nc, ip, w + nw);        return;}void rdft(int n, int isgn, t_double *a, int *ip, t_double *w){        int		j,    nw,    nc;        t_double		xi;        void		bitrv2(int n, int *ip, t_double *a),    cftsub(int n, t_double *a, t_double *w),    rftsub(int n, t_double *a, int nc, t_double *c);            nw = ip[0];    nc = ip[1];        if (isgn < 0) {        a[1] = 0.5 * (a[1] - a[0]);        a[0] += a[1];                for (j = 3; j <= n - 1; j += 2) {            a[j] = -a[j];        }                if (n > 4) {            rftsub(n, a, nc, w + nw);            bitrv2(n, ip + 2, a);        }                cftsub(n, a, w);                for (j = 1; j <= n - 1; j += 2) {            a[j] = -a[j];        }    }        else {                if (n > 4) {            bitrv2(n, ip + 2, a);        }                cftsub(n, a, w);                if (n > 4) {            rftsub(n, a, nc, w + nw);        }                xi = a[0] - a[1];        a[0] += a[1];        a[1] = xi;    }}void bitrv2(int n, int *ip, t_double *a){    int j, j1, k, k1, l, m, m2;    float xr, xi;        ip[0] = 0;    l = n;    m = 1;        while ((m << 2) < l) {        l >>= 1;        for (j = 0; j <= m - 1; j++) {            ip[m + j] = ip[j] + l;        }        m <<= 1;    }        if ((m << 2) > l) {                for (k = 1; k <= m - 1; k++) {                        for (j = 0; j <= k - 1; j++) {                j1 = (j << 1) + ip[k];                k1 = (k << 1) + ip[j];                xr = a[j1];                xi = a[j1 + 1];                a[j1] = a[k1];                a[j1 + 1] = a[k1 + 1];                a[k1] = xr;                a[k1 + 1] = xi;            }        }    }        else {        m2 = m << 1;                for (k = 1; k <= m - 1; k++) {                        for (j = 0; j <= k - 1; j++) {                j1 = (j << 1) + ip[k];                k1 = (k << 1) + ip[j];                xr = a[j1];                xi = a[j1 + 1];                a[j1] = a[k1];                a[j1 + 1] = a[k1 + 1];                a[k1] = xr;                a[k1 + 1] = xi;                j1 += m2;                k1 += m2;                xr = a[j1];                xi = a[j1 + 1];                a[j1] = a[k1];                a[j1 + 1] = a[k1 + 1];                a[k1] = xr;                a[k1 + 1] = xi;            }        }    }}void cftsub(int n, t_double *a, t_double *w){    int j, j1, j2, j3, k, k1, ks, l, m;    float wk1r, wk1i, wk2r, wk2i, wk3r, wk3i;    float x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;        l = 2;        while ((l << 1) < n) {        m = l << 2;                for (j = 0; j <= l - 2; j += 2) {            j1 = j + l;            j2 = j1 + l;            j3 = j2 + l;            x0r = a[j] + a[j1];            x0i = a[j + 1] + a[j1 + 1];            x1r = a[j] - a[j1];            x1i = a[j + 1] - a[j1 + 1];            x2r = a[j2] + a[j3];            x2i = a[j2 + 1] + a[j3 + 1];            x3r = a[j2] - a[j3];            x3i = a[j2 + 1] - a[j3 + 1];            a[j] = x0r + x2r;            a[j + 1] = x0i + x2i;            a[j2] = x0r - x2r;            a[j2 + 1] = x0i - x2i;            a[j1] = x1r - x3i;            a[j1 + 1] = x1i + x3r;            a[j3] = x1r + x3i;            a[j3 + 1] = x1i - x3r;        }                if (m < n) {            wk1r = w[2];                        for (j = m; j <= l + m - 2; j += 2) {                j1 = j + l;                j2 = j1 + l;                j3 = j2 + l;                x0r = a[j] + a[j1];                x0i = a[j + 1] + a[j1 + 1];                x1r = a[j] - a[j1];                x1i = a[j + 1] - a[j1 + 1];                x2r = a[j2] + a[j3];                x2i = a[j2 + 1] + a[j3 + 1];                x3r = a[j2] - a[j3];                x3i = a[j2 + 1] - a[j3 + 1];                a[j] = x0r + x2r;                a[j + 1] = x0i + x2i;                a[j2] = x2i - x0i;                a[j2 + 1] = x0r - x2r;                x0r = x1r - x3i;                x0i = x1i + x3r;                a[j1] = wk1r * (x0r - x0i);                a[j1 + 1] = wk1r * (x0r + x0i);                x0r = x3i + x1r;                x0i = x3r - x1i;                a[j3] = wk1r * (x0i - x0r);                a[j3 + 1] = wk1r * (x0i + x0r);            }                        k1 = 1;            ks = -1;                        for (k = (m << 1); k <= n - m; k += m) {                k1++;                ks = -ks;                wk1r = w[k1 << 1];                wk1i = w[(k1 << 1) + 1];                wk2r = ks * w[k1];                wk2i = w[k1 + ks];                wk3r = wk1r - 2 * wk2i * wk1i;                wk3i = 2 * wk2i * wk1r - wk1i;                                for (j = k; j <= l + k - 2; j += 2) {                    j1 = j + l;                    j2 = j1 + l;                    j3 = j2 + l;                    x0r = a[j] + a[j1];                    x0i = a[j + 1] + a[j1 + 1];                    x1r = a[j] - a[j1];                    x1i = a[j + 1] - a[j1 + 1];                    x2r = a[j2] + a[j3];                    x2i = a[j2 + 1] + a[j3 + 1];                    x3r = a[j2] - a[j3];                    x3i = a[j2 + 1] - a[j3 + 1];                    a[j] = x0r + x2r;                    a[j + 1] = x0i + x2i;                    x0r -= x2r;                    x0i -= x2i;                    a[j2] = wk2r * x0r - wk2i * x0i;                    a[j2 + 1] = wk2r * x0i + wk2i * x0r;                    x0r = x1r - x3i;                    x0i = x1i + x3r;                    a[j1] = wk1r * x0r - wk1i * x0i;                    a[j1 + 1] = wk1r * x0i + wk1i * x0r;                    x0r = x1r + x3i;                    x0i = x1i - x3r;                    a[j3] = wk3r * x0r - wk3i * x0i;                    a[j3 + 1] = wk3r * x0i + wk3i * x0r;                }            }        }                l = m;    }        if (l < n) {                for (j = 0; j <= l - 2; j += 2) {            j1 = j + l;            x0r = a[j] - a[j1];            x0i = a[j + 1] - a[j1 + 1];            a[j] += a[j1];            a[j + 1] += a[j1 + 1];            a[j1] = x0r;            a[j1 + 1] = x0i;        }    }}void rftsub(int n, t_double *a, int nc, t_double *c){    int j, k, kk, ks;    float wkr, wki, xr, xi, yr, yi;        ks = (nc << 2) / n;    kk = 0;        for (k = (n >> 1) - 2; k >= 2; k -= 2) {        j = n - k;        kk += ks;        wkr = 0.5 - c[kk];        wki = c[nc - kk];        xr = a[k] - a[j];        xi = a[k + 1] + a[j + 1];        yr = wkr * xr - wki * xi;        yi = wkr * xi + wki * xr;        a[k] -= yr;        a[k + 1] -= yi;        a[j] += yr;        a[j + 1] -= yi;    }}void makewt(int nw, int *ip, t_double *w){    void bitrv2(int n, int *ip, t_double *a);    int nwh, j;    float delta, x, y;        ip[0] = nw;    ip[1] = 1;    if (nw > 2) {        nwh = nw >> 1;        delta = atan(1.0) / nwh;        w[0] = 1;        w[1] = 0;        w[nwh] = cos(delta * nwh);        w[nwh + 1] = w[nwh];        for (j = 2; j <= nwh - 2; j += 2) {            x = cos(delta * j);            y = sin(delta * j);            w[j] = x;            w[j + 1] = y;            w[nw - j] = y;            w[nw - j + 1] = x;        }        bitrv2(nw, ip + 2, w);    }}void makect(int nc, int *ip, t_double *c){    int nch, j;    t_double delta;        ip[1] = nc;    if (nc > 1) {        nch = nc >> 1;        delta = atan(1.0) / nch;        c[0] = 0.5;        c[nch] = 0.5 * cos(delta * nch);        for (j = 1; j <= nch - 1; j++) {            c[j] = 0.5 * cos(delta * j);            c[nc - j] = 0.5 * sin(delta * j);        }    }}void convert(t_double *S, t_double *C, int N2, t_double *lastphase, t_double fundamental, t_double factor ){    float 	phase,    phasediff;    int 		real,    imag,    amp,    freq;    float 	a,    b;    int 		i;        /*  float myTWOPI, myPI; */    /*  double sin(), cos(), atan(), hypot();*/        /*  myTWOPI = 8.*atan(1.);     myPI = 4.*atan(1.); */            for ( i = 0; i <= N2; i++ ) {        imag = freq = ( real = amp = i<<1 ) + 1;        a = ( i == N2 ? S[1] : S[real] );        b = ( i == 0 || i == N2 ? 0. : S[imag] );                C[amp] = hypot( a, b );        if ( C[amp] == 0. )            phasediff = 0.;        else {            phasediff = ( phase = -atan2( b, a ) ) - lastphase[i];            lastphase[i] = phase;                        while ( phasediff > PI )                phasediff -= TWOPI;            while ( phasediff < -PI )                phasediff += TWOPI;        }        C[freq] = phasediff*factor + i*fundamental;    }}void fold( t_double *I, t_double *W, int Nw, t_double *O, int N, int n ){        int i;        for ( i = 0; i < N; i++ )        O[i] = 0.;        while ( n < 0 )        n += N;    n %= N;    for ( i = 0; i < Nw; i++ ) {        O[n] += I[i]*W[i];        if ( ++n == N )            n = 0;    }}void makehanning( t_double *H, t_double *A, t_double *S, int Nw, int N, int I, int odd ){    int i;    float sum ;            if (odd) {        for ( i = 0 ; i < Nw ; i++ )            H[i] = A[i] = S[i] = sqrt(0.5 * (1. + cos(PI + TWOPI * i / (Nw - 1))));    }        else {                for ( i = 0 ; i < Nw ; i++ )            H[i] = A[i] = S[i] = 0.5 * (1. + cos(PI + TWOPI * i / (Nw - 1)));            }        if ( Nw > N ) {        float x ;                x = -(Nw - 1)/2. ;        for ( i = 0 ; i < Nw ; i++, x += 1. )            if ( x != 0. ) {                A[i] *= N*sin( PI*x/N )/(PI*x) ;                if ( I )                    S[i] *= I*sin( PI*x/I )/(PI*x) ;            }    }    for ( sum = i = 0 ; i < Nw ; i++ )        sum += A[i] ;        for ( i = 0 ; i < Nw ; i++ ) {        float afac = 2./sum ;        float sfac = Nw > N ? 1./afac : afac ;        A[i] *= afac ;        S[i] *= sfac ;    }        if ( Nw <= N && I ) {        for ( sum = i = 0 ; i < Nw ; i += I )            sum += S[i]*S[i] ;        for ( sum = 1./sum, i = 0 ; i < Nw ; i++ )            S[i] *= sum ;    }}